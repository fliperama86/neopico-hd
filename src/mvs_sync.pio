;
; MVS CSYNC Decoder - Phase 4a: Horizontal Counter
;
; Input pins:
;   GPIO 22: CSYNC (moved from 16 for DVI)
;   GPIO 28: PCLK (pixel clock, 6 MHz) (moved from 17 for DVI)
;

.program mvs_sync_4a

public entry_point:
.wrap_target
    ; Wait for CSYNC to be high (start of a line)
    wait 1 gpio 22              ; Wait for CSYNC high
    set x, 0                    ; h_ctr = 0, start counting

pixel_loop:
    ; Wait for pixel clock edge
    wait 0 gpio 28              ; Wait for PCLK falling
    wait 1 gpio 28              ; Wait for PCLK rising

    ; Increment h_ctr (X counts down from 0, so decrement)
    jmp x-- skip_inc            ; X--, skip if not zero
skip_inc:

    ; Check if CSYNC went low (falling edge detected)
    jmp pin pixel_loop          ; If CSYNC is high, continue counting

csync_falling:
    ; CSYNC falling edge detected - push h_ctr
    ; Convert X (counts down) to actual count (counts up)
    mov isr, !x                 ; ISR = ~X (inverted = actual count)
    push noblock                ; Push to FIFO

    ; Wait for CSYNC to go back high before next line
    wait 1 gpio 22              ; Wait for CSYNC high (end of sync pulse)
    set x, 0                    ; Reset counter for next line
    jmp pixel_loop              ; Start counting next line

.wrap


% c-sdk {

void mvs_sync_4a_program_init(PIO pio, uint sm, uint offset, uint pin_csync, uint pin_pclk) {
    pio_sm_config c = mvs_sync_4a_program_get_default_config(offset);

    // Configure input pins
    sm_config_set_in_pins(&c, pin_csync);

    // Initialize GPIO pins for PIO use
    pio_gpio_init(pio, pin_csync);
    pio_gpio_init(pio, pin_pclk);

    // Set pins as inputs
    pio_sm_set_consecutive_pindirs(pio, sm, pin_csync, 1, false);
    pio_sm_set_consecutive_pindirs(pio, sm, pin_pclk, 1, false);

    // Enable pull-downs to reduce noise
    gpio_pull_down(pin_csync);
    gpio_pull_down(pin_pclk);

    // Configure JMP pin for CSYNC (used in 'jmp pin')
    sm_config_set_jmp_pin(&c, pin_csync);

    // Run at full speed (125 MHz PIO clock)
    sm_config_set_clkdiv(&c, 1.0f);

    // Configure ISR: shift right, no autopush (we push manually)
    sm_config_set_in_shift(&c, false, false, 32);

    // Double RX FIFO depth
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);

    // Initialize and start state machine at entry_point
    pio_sm_init(pio, sm, offset + mvs_sync_4a_offset_entry_point, &c);
    pio_sm_set_enabled(pio, sm, true);
}

%}


;
; MVS Pixel Capture - 16-bit RGB (R5G5B5 + dummy)
;
; Captures 16 bits per pixel clock:
;   GPIO 0-4:   R0-R4 (5 red bits)
;   GPIO 5-9:   G0-G4 (5 green bits)
;   GPIO 10-14: B0-B4 (5 blue bits)
;   GPIO 15:    GND (dummy for 16-bit alignment)
;   GPIO 22:    CSYNC (moved from 16 for DVI)
;   GPIO 28:    PCLK (moved from 17 for DVI)
;

.program mvs_pixel_capture

    ; Wait for trigger signal from C code (IRQ 4)
    wait 1 irq 4

    ; Wait for CSYNC to be LOW (we might be mid-line)
    wait 0 gpio 22

    ; Wait for CSYNC to go HIGH (start of new line)
    wait 1 gpio 22

    ; Sync to pixel clock
    wait 0 gpio 28
    wait 1 gpio 28

.wrap_target
    ; Wait for PCLK rising edge
    wait 0 gpio 28
    wait 1 gpio 28

    ; Sample 16 bits: R0-R4, G0-G4, B0-B4, GND (GPIO 0-15)
    ; Autopush at 32 bits = 2 pixels per word
    in pins, 16
.wrap


% c-sdk {

void mvs_pixel_capture_program_init(PIO pio, uint sm, uint offset, uint pin_r0, uint pin_gnd, uint pin_csync, uint pin_pclk) {
    pio_sm_config c = mvs_pixel_capture_program_get_default_config(offset);

    // Configure input pins starting at R0 (GPIO 0)
    sm_config_set_in_pins(&c, pin_r0);

    // Initialize all GPIO pins for PIO use (0-15 for RGB+GND, 16-17 for sync/clock)
    for (uint i = pin_r0; i <= pin_gnd; i++) {
        pio_gpio_init(pio, i);
    }
    pio_gpio_init(pio, pin_csync);
    pio_gpio_init(pio, pin_pclk);

    // Set pins as inputs
    pio_sm_set_consecutive_pindirs(pio, sm, pin_r0, 16, false);  // R0-B4 + GND
    pio_sm_set_consecutive_pindirs(pio, sm, pin_csync, 1, false);
    pio_sm_set_consecutive_pindirs(pio, sm, pin_pclk, 1, false);

    // Enable pull-downs on RGB pins
    for (uint i = pin_r0; i <= pin_gnd; i++) {
        gpio_pull_down(i);
    }
    gpio_pull_down(pin_csync);
    gpio_pull_down(pin_pclk);

    // Run at full speed
    sm_config_set_clkdiv(&c, 1.0f);

    // Configure ISR: shift right, autopush every 32 bits (2 pixels)
    sm_config_set_in_shift(&c, true, true, 32);

    // Double RX FIFO depth
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);

    // Initialize and start
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}

%}