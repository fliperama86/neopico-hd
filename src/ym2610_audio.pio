; YM2610 Serial Audio Receiver for Neo Geo MVS
;
; Captures digital audio from YM2610 -> YM3016 serial interface
; Pin mapping (protoboard setup):
;   GPIO 21: BCK (Ã¸S) - bit clock (~2.66 MHz)
;   GPIO 23: DAT (OPO) - serial data (in_base)
;   GPIO 24: WS (SH1) - word select (~55.5 kHz)
;
; MVS Format (verified via logic analyzer):
;   48 BCK cycles per WS period (24 per channel)
;   Each channel: 8-bit padding (zeros) + 16-bit data
;
; YM2610 16-bit data format:
;   bits[15:13] = 3-bit exponent
;   bits[12:3]  = 10-bit mantissa (signed, offset by 512)
;   bits[2:0]   = padding
; Decode: (mantissa - 512) << (exponent - 1)
;
; Timing:
;   WS FALLING = start of LEFT channel
;   WS RISING  = start of RIGHT channel
;   BCK 1-8:   padding (skip)
;   BCK 9-24:  16-bit data (capture)
;   Sample DAT on BCK RISING edge

.program ym2610_rx

; Capture ALL 24 bits per channel to see full frame
; Right-justified format: WS=1 is LEFT, WS=0 is RIGHT
; Wait for WS low (right channel) first to sync
    wait 0 gpio 24

.wrap_target
    ; === LEFT CHANNEL ===
    wait 1 gpio 24              ; Wait for WS rising edge (LEFT starts)

    ; Capture 24 bits on BCK rising edge
    set x, 23
left_loop:
    wait 0 gpio 21
    wait 1 gpio 21              ; Rising edge
    in pins, 1
    jmp x-- left_loop
    push noblock                ; Push 24 bits (in lower 24 of 32-bit word)

    ; === RIGHT CHANNEL ===
    wait 0 gpio 24              ; Wait for WS falling edge (RIGHT starts)

    set x, 23
right_loop:
    wait 0 gpio 21
    wait 1 gpio 21
    in pins, 1
    jmp x-- right_loop
    push noblock
.wrap

% c-sdk {
// Pin definitions (protoboard setup):
// AUDIO_PIN_BCK = 21, AUDIO_PIN_DAT = 23, AUDIO_PIN_WS = 24
static inline void ym2610_rx_program_init(PIO pio, uint sm, uint offset, uint pin_dat) {
    pio_sm_config c = ym2610_rx_program_get_default_config(offset);

    // Pin mapping (must match PIO wait instructions):
    //   GPIO 21: BCK (bit clock)
    //   GPIO 23: DAT (serial data) - passed as pin_dat
    //   GPIO 24: WS (word select)

    // Set IN pin base to DAT for sampling
    sm_config_set_in_pins(&c, pin_dat);

    // Shift LEFT (MSB first), no autopush - we push manually after 24 bits
    sm_config_set_in_shift(&c, false, false, 32);

    // Configure all three pins as inputs
    pio_sm_set_pindirs_with_mask(pio, sm, 0,
        (1u << 21) | (1u << pin_dat) | (1u << 24));

    // Initialize GPIO for PIO
    pio_gpio_init(pio, 21);       // BCK
    pio_gpio_init(pio, pin_dat);  // DAT
    pio_gpio_init(pio, 24);       // WS

    // No clock divider - run at full speed
    sm_config_set_clkdiv(&c, 1.0f);

    // Initialize and start
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}
%}
