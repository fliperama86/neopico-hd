;
; MVS CSYNC Decoder - Phase 4a: Horizontal Counter
;
; Input pins:
;   GPIO 22: CSYNC
;   GPIO 0:  PCLK (pixel clock, 6 MHz)
;

.program mvs_sync_4a

public entry_point:
.wrap_target
    ; Wait for CSYNC to be high (start of a line)
    wait 1 gpio 22              ; Wait for CSYNC high
    set x, 0                    ; h_ctr = 0, start counting

pixel_loop:
    ; Wait for pixel clock edge
    wait 0 gpio 0               ; Wait for PCLK falling
    wait 1 gpio 0               ; Wait for PCLK rising

    ; Increment h_ctr (X counts down from 0, so decrement)
    jmp x-- skip_inc            ; X--, skip if not zero
skip_inc:

    ; Check if CSYNC went low (falling edge detected)
    jmp pin pixel_loop          ; If CSYNC is high, continue counting

csync_falling:
    ; CSYNC falling edge detected - push h_ctr
    ; Convert X (counts down) to actual count (counts up)
    mov isr, !x                 ; ISR = ~X (inverted = actual count)
    push noblock                ; Push to FIFO

    ; Wait for CSYNC to go back high before next line
    wait 1 gpio 22              ; Wait for CSYNC high (end of sync pulse)
    set x, 0                    ; Reset counter for next line
    jmp pixel_loop              ; Start counting next line

.wrap


% c-sdk {

void mvs_sync_4a_program_init(PIO pio, uint sm, uint offset, uint pin_csync, uint pin_pclk) {
    pio_sm_config c = mvs_sync_4a_program_get_default_config(offset);

    // Configure input pins
    sm_config_set_in_pins(&c, pin_csync);

    // Initialize GPIO pins for PIO use
    pio_gpio_init(pio, pin_csync);
    pio_gpio_init(pio, pin_pclk);

    // Set pins as inputs
    pio_sm_set_consecutive_pindirs(pio, sm, pin_csync, 1, false);
    pio_sm_set_consecutive_pindirs(pio, sm, pin_pclk, 1, false);

    // Enable pull-downs to reduce noise
    gpio_pull_down(pin_csync);
    gpio_pull_down(pin_pclk);

    // Configure JMP pin for CSYNC (used in 'jmp pin')
    sm_config_set_jmp_pin(&c, pin_csync);

    // Run at full speed (125 MHz PIO clock)
    sm_config_set_clkdiv(&c, 1.0f);

    // Configure ISR: shift right, no autopush (we push manually)
    sm_config_set_in_shift(&c, false, false, 32);

    // Double RX FIFO depth
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);

    // Initialize and start state machine at entry_point
    pio_sm_init(pio, sm, offset + mvs_sync_4a_offset_entry_point, &c);
    pio_sm_set_enabled(pio, sm, true);
}

%}


;
; MVS Pixel Capture - 16-bit RGB
;
; Captures 16 bits per pixel clock:
;   GPIO 0:     PCLK (ignored in data, but captured for alignment)
;   GPIO 1-5:   G4-G0 (5 green bits, reversed order)
;   GPIO 6-10:  B0-B4 (5 blue bits)
;   GPIO 11-15: R0-R4 (5 red bits)
;   GPIO 22:    CSYNC
;

.program mvs_pixel_capture

    ; Wait for trigger signal from C code (IRQ 4)
    wait 1 irq 4

    ; Wait for CSYNC to be LOW (we might be mid-line)
    wait 0 gpio 22

    ; Wait for CSYNC to go HIGH (start of new line)
    wait 1 gpio 22

    ; Sync to pixel clock
    wait 0 gpio 0
    wait 1 gpio 0

.wrap_target
    ; Wait for PCLK rising edge
    wait 0 gpio 0
    wait 1 gpio 0

    ; Sample 16 bits: PCLK, G4-G0, B0-B4, R0-R4 (GPIO 0-15)
    ; Autopush at 32 bits = 2 pixels per word
    in pins, 16
.wrap


% c-sdk {

void mvs_pixel_capture_program_init(PIO pio, uint sm, uint offset, uint pin_base, uint pin_csync, uint pin_pclk) {
    pio_sm_config c = mvs_pixel_capture_program_get_default_config(offset);

    // Configure input pins starting at PCLK (GPIO 0)
    // We capture 16 bits: GPIO 0 (PCLK), GPIO 1-15 (RGB data)
    sm_config_set_in_pins(&c, pin_base);

    // Initialize all GPIO pins for PIO use (0-15 for PCLK+RGB, 17 for CSYNC)
    for (uint i = pin_base; i < pin_base + 16; i++) {
        pio_gpio_init(pio, i);
    }
    pio_gpio_init(pio, pin_csync);

    // Set pins as inputs
    pio_sm_set_consecutive_pindirs(pio, sm, pin_base, 16, false);  // PCLK + RGB
    pio_sm_set_consecutive_pindirs(pio, sm, pin_csync, 1, false);

    // Enable pull-downs on data pins (skip PCLK at pin_base)
    for (uint i = pin_base + 1; i < pin_base + 16; i++) {
        gpio_pull_down(i);
    }
    gpio_pull_down(pin_csync);

    // Run at full speed
    sm_config_set_clkdiv(&c, 1.0f);

    // Configure ISR: shift right, autopush every 32 bits (2 pixels)
    sm_config_set_in_shift(&c, true, true, 32);

    // Double RX FIFO depth
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);

    // Initialize and start
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}

%}