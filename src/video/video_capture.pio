; MVS CSYNC Decoder
;
; TEMPORARY: Reverting to original (broken but booting) version
; TODO: Fix window-relative GPIO indices incrementally

.program mvs_sync_4a

public entry_point:
    wait 1 pin 0               ; Wait for CSYNC High (IN_BASE=GP43)
    mov x, !null                ; Initialize counter
count_loop:
    wait 0 pin 14              ; Wait for PCLK Low (GP25 is -18 from GP43, index 14)
    wait 1 pin 14              ; Wait for PCLK High (GP25)
    jmp x-- check_pin           ; Decrement X
check_pin:
    jmp pin count_loop          ; If CSYNC is still High, keep counting (JMP_PIN=GP43)

    ; CSYNC went Low - push count
    mov isr, !x
    push noblock
    jmp entry_point


; MVS Pixel Capture - 18-bit with CONTIGUOUS fields (optimized!)
;
; GP25-42 CAPTURE (18 pins):
;   IN_BASE = 25 (GP25)
;   Captures 18 consecutive pins starting from IN_BASE:
;     Bit 0:     GP25 (PCLK - position 0!)
;     Bits 1-5:  GP26-30 (Red R0-R4, contiguous)
;     Bits 6-10: GP31-35 (Green G0-G4, contiguous)
;     Bits 11-15: GP36-40 (Blue B0-B4, contiguous)
;     Bit 16:    GP41 (DARK)
;     Bit 17:    GP42 (SHADOW)
;
; Autopush at 18 bits = 1 pixel per FIFO word (14 bits unused)

.program mvs_pixel_capture

    ; Wait for trigger signal from C code (IRQ 4)
    wait 1 irq 4

    ; Sync to line start
    wait 0 pin 18              ; Wait for CSYNC LOW (GP43 is +18 from GP25)
    wait 1 pin 18              ; Wait for CSYNC HIGH (start of new line)

    ; Sync to pixel clock
    wait 0 pin 0               ; GP25 (PCLK)
    wait 1 pin 0               ; PCLK rising edge

.wrap_target
    ; Wait for PCLK rising edge
    wait 0 pin 0               ; GP25 (PCLK)
    wait 1 pin 0               ; PCLK rising edge

    ; Sample 18 bits: GP25-42 (PCLK + RGB555 + DARK + SHADOW)
    ; PCLK at bit 0, contiguous RGB fields for fast extraction
    ; Autopush at 18 bits = 1 pixel per word
    in pins, 18
.wrap
