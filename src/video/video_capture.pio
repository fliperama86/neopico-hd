; MVS CSYNC Decoder
;
; TEMPORARY: Reverting to original (broken but booting) version
; TODO: Fix window-relative GPIO indices incrementally

.program mvs_sync_4a

public entry_point:
    wait 1 pin 0               ; Wait for CSYNC High (IN_BASE=GP43)
    mov x, !null                ; Initialize counter
count_loop:
    wait 0 pin 14              ; Wait for PCLK Low (GP25 is -18 from GP43, index 14)
    wait 1 pin 14              ; Wait for PCLK High (GP25)
    jmp x-- check_pin           ; Decrement X
check_pin:
    jmp pin count_loop          ; If CSYNC is still High, keep counting (JMP_PIN=GP43)

    ; CSYNC went Low - push count
    mov isr, !x
    push noblock
    jmp entry_point


; MVS Pixel Capture - 18-bit with CONTIGUOUS fields (optimized!)
;
; GP25-42 CAPTURE (18 pins):
;   IN_BASE = 25 (GP25)
;   Captures 18 consecutive pins starting from IN_BASE:
;     Bit 0:     GP25 (PCLK - position 0!)
;     Bits 1-5:  GP26-30 (Red R0-R4, contiguous)
;     Bits 6-10: GP31-35 (Green G0-G4, contiguous)
;     Bits 11-15: GP36-40 (Blue B0-B4, contiguous)
;     Bit 16:    GP41 (DARK)
;     Bit 17:    GP42 (SHADOW)
;
; Autopush at 18 bits = 1 pixel per FIFO word (14 bits unused)

.program mvs_pixel_capture

    ; One-time initialization: C code will push (NEO_H_TOTAL - 1)
    pull block
    mov y, osr

    ; Wait for trigger signal from C code (IRQ 4) at start of frame
    ; Moving this OUTSIDE the wrap target so it only happens once per frame.
    wait 1 irq 4

.wrap_target
    ; 1. Sync to line start (CSYNC GP43 is at offset 18 from IN_BASE=GP25)
    wait 0 pin 18              ; Wait for CSYNC LOW
    wait 1 pin 18              ; Wait for CSYNC HIGH

    ; 2. Sample NEO_H_TOTAL pixels
    mov x, y                   ; Reset pixel counter
pixel_loop:
    wait 0 pin 0               ; GP25 (PCLK) LOW
    wait 1 pin 0               ; PCLK HIGH (rising edge)
    in pins, 18                ; Sample GP25-42
    jmp x-- pixel_loop         ; Loop until line complete
.wrap
