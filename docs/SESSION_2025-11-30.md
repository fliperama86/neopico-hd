# Session Summary - 2025-11-30

## Mission: Add DVI/HDMI Output to MVS Capture

**Initial Status**: Working USB streaming capture at 4-bit RGB
**Final Status**: 240p HDMI output at 60fps!

---

## Major Achievements

### 1. DVI Output via PicoDVI Library
- Integrated PicoDVI library for HDMI output on RP2350
- Custom pin configuration for NeoPico-HD hardware:
  - DVI Data: GPIO 16-21 (3 differential pairs)
  - DVI Clock: GPIO 26-27
  - MVS signals moved: CSYNC to GPIO 22, PCLK to GPIO 28

### 2. Native 240p Output
- Custom 640x240 timing at 60Hz (126 MHz bit clock)
- RT4K recognizes as 240p and handles upscaling
- Lower pixel clock = more stable on breadboard/prototype wiring

### 3. Line-by-Line Capture for 60fps
- Eliminated raw DMA buffer (saved 192KB RAM!)
- Read pixels directly from PIO FIFO
- Process and convert while receiving - no post-processing delay
- Result: True 60fps capture matching MVS refresh rate

### 4. Full 15-bit RGB Capture Working
- All 5 bits per channel (R5G5B5) + dummy GND bit = 16 bits per pixel
- Proper color conversion: MVS RGB555 → RGB565 for DVI

### 5. Reference Implementations Studied
- **cps2_digiav** (marqs85) - FPGA-based MVS HDMI, provided timing constants
- **PicoDVI-N64** (kbeckmann) - Pico-based N64 capture, provided architecture pattern

---

## Key Technical Findings

### MVS Timing Constants (from cps2_digiav neogeo_frontend.v)
```c
#define NEO_H_TOTAL 384        // Total pixels per line
#define NEO_H_ACTIVE 320       // Active pixels
#define H_SKIP_START 28        // Pixels to skip at line start
#define H_SKIP_END 36          // Pixels to skip at line end

#define NEO_V_ACTIVE 224       // Active lines
#define V_SKIP_LINES 16        // Lines to skip after vsync
```

### 240p DVI Timing
```c
static const struct dvi_timing dvi_timing_640x240p_60hz = {
    .h_front_porch     = 16,
    .h_sync_width      = 96,
    .h_back_porch      = 48,
    .h_active_pixels   = 640,

    .v_front_porch     = 3,
    .v_sync_width      = 3,
    .v_back_porch      = 16,
    .v_active_lines    = 240,

    .bit_clk_khz       = 126000  // Half of 480p for 60Hz
};
```

### Line-by-Line Capture Algorithm
```c
for each frame:
    wait_for_vsync()
    skip V_SKIP_LINES lines
    for each of 224 active lines:
        skip H_SKIP_START/2 words (blanking)
        read 160 words (320 pixels)
        convert RGB555 → RGB565
        write to framebuffer
        skip H_SKIP_END/2 words (blanking)
```

---

## Architecture Overview

### Final Working Architecture (60fps)
```
Core 0: Line-by-Line Capture      Core 1: DVI Output
┌─────────────────────────┐      ┌─────────────────────────┐
│ 1. Wait for vsync       │      │ scanline_callback()     │
│ 2. For each line:       │      │ - Returns row pointers  │
│    - Skip blanking      │      │ - Runs at 60Hz          │
│    - Read from PIO FIFO │      │ - Reads from g_framebuf │
│    - Convert pixels     │      │                         │
│    - Write to framebuf  │      │ dvi_scanbuf_main_16bpp()│
│ 3. Loop (~16.7ms total) │      │                         │
└─────────────────────────┘      └─────────────────────────┘
         │                                   │
         └──────── g_framebuf ───────────────┘
               (320×240, 150KB only!)
```

### PIO Assignment
- **PIO0**: DVI output (3 state machines for TMDS encoding)
- **PIO1**: MVS sync detection + pixel capture (2 state machines)

---

## Evolution of Approaches

### Attempt 1: DMA + process_frame() (30fps)
- Captured full frame via DMA to raw_buffer (192KB)
- Post-processed entire frame
- Result: 30fps (capture + processing = 2 frame times)

### Attempt 2: Double Buffering (crashed)
- Tried to process previous frame while capturing next
- RAM overflow (520KB limit exceeded)
- Result: Unstable, crashes

### Attempt 3: 240p + Line-by-Line (60fps!) ✓
- Reduced output to 240p (less TMDS encoding work)
- Read directly from PIO FIFO per line
- No raw buffer needed at all
- Result: 60fps, stable, clean image

---

## What Didn't Work

### 1. Custom 59.19Hz DVI Timing
- Created timing to match MVS exactly
- RT4K scaler rejected it (no signal)
- Standard displays may not accept non-standard refresh rates

### 2. 480p at 60fps
- TMDS encoding at 252 MHz bit clock
- Combined with capture overhead = too slow

### 3. GPIO-based HSYNC Wait
- Added explicit GPIO waits for CSYNC synchronization
- Made horizontal shifting worse, not better
- PIO-based sync is more deterministic

---

## Files Modified/Created

### Source Code
- **src/main_dvi.c** - Line-by-line capture + 240p DVI output
- **src/CMakeLists.txt** - Added DVI_VERTICAL_REPEAT=1

### Documentation
- **README.md** - Complete rewrite for current status
- **docs/SESSION_2025-11-30.md** - This file

### Reference (cloned for future use)
- **reference/cps2_digiav/** - FPGA MVS/CPS implementation
- **reference/PicoDVI-N64/** - N64 capture reference

---

## Performance Summary

| Metric | Before | After |
|--------|--------|-------|
| **Output resolution** | 640×480 | 640×240 (240p) |
| **Frame rate** | 30fps | 60fps |
| **RAM usage** | ~350KB | ~150KB |
| **Processing** | Post-frame | Per-line |
| **Horizontal glitches** | Occasional | None |

---

## Conclusion

Native 240p output at 60fps achieved! The key insights:

1. **240p is better** - Let the RT4K handle scaling with its superior algorithms
2. **Line-by-line is faster** - Process while receiving instead of after
3. **Less is more** - Eliminating the raw buffer saved RAM and time
4. **Lower clock = stability** - 126 MHz bit clock is more forgiving on prototype wiring

**Status**: Production ready for real-world use!
